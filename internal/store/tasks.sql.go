// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acquireWorkspaceLock = `-- name: AcquireWorkspaceLock :exec
SELECT pg_advisory_xact_lock(hashtext($1))
`

func (q *Queries) AcquireWorkspaceLock(ctx context.Context, hashtext string) error {
	_, err := q.db.Exec(ctx, acquireWorkspaceLock, hashtext)
	return err
}

const cancelPendingTask = `-- name: CancelPendingTask :one
UPDATE wvs.tasks SET status = 'CANCELED', ended_at = now()
WHERE task_id = $1 AND status = 'PENDING'
RETURNING task_id, wsid, op, status, idempotency_key, request_hash, created_at, started_at, ended_at, attempt, max_attempts, next_run_at, timeout_seconds, cancel_requested, params, result, error
`

func (q *Queries) CancelPendingTask(ctx context.Context, taskID string) (WvsTask, error) {
	row := q.db.QueryRow(ctx, cancelPendingTask, taskID)
	var i WvsTask
	err := row.Scan(
		&i.TaskID,
		&i.Wsid,
		&i.Op,
		&i.Status,
		&i.IdempotencyKey,
		&i.RequestHash,
		&i.CreatedAt,
		&i.StartedAt,
		&i.EndedAt,
		&i.Attempt,
		&i.MaxAttempts,
		&i.NextRunAt,
		&i.TimeoutSeconds,
		&i.CancelRequested,
		&i.Params,
		&i.Result,
		&i.Error,
	)
	return i, err
}

const completeTask = `-- name: CompleteTask :exec
UPDATE wvs.tasks
SET status = $2, ended_at = now(), result = $3, error = $4
WHERE task_id = $1
`

type CompleteTaskParams struct {
	TaskID string `json:"task_id"`
	Status string `json:"status"`
	Result []byte `json:"result"`
	Error  []byte `json:"error"`
}

func (q *Queries) CompleteTask(ctx context.Context, arg CompleteTaskParams) error {
	_, err := q.db.Exec(ctx, completeTask,
		arg.TaskID,
		arg.Status,
		arg.Result,
		arg.Error,
	)
	return err
}

const countActiveTasks = `-- name: CountActiveTasks :one
SELECT count(*) FROM wvs.tasks
WHERE wsid = $1 AND status IN ('PENDING', 'RUNNING', 'FAILED') AND attempt < max_attempts
`

func (q *Queries) CountActiveTasks(ctx context.Context, wsid string) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveTasks, wsid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO wvs.tasks (task_id, wsid, op, status, idempotency_key, request_hash, params, max_attempts, timeout_seconds)
VALUES ($1, $2, $3, 'PENDING', $4, $5, $6, $7, $8)
RETURNING task_id, wsid, op, status, idempotency_key, request_hash, created_at, started_at, ended_at, attempt, max_attempts, next_run_at, timeout_seconds, cancel_requested, params, result, error
`

type CreateTaskParams struct {
	TaskID         string `json:"task_id"`
	Wsid           string `json:"wsid"`
	Op             string `json:"op"`
	IdempotencyKey string `json:"idempotency_key"`
	RequestHash    string `json:"request_hash"`
	Params         []byte `json:"params"`
	MaxAttempts    int32  `json:"max_attempts"`
	TimeoutSeconds int32  `json:"timeout_seconds"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (WvsTask, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.TaskID,
		arg.Wsid,
		arg.Op,
		arg.IdempotencyKey,
		arg.RequestHash,
		arg.Params,
		arg.MaxAttempts,
		arg.TimeoutSeconds,
	)
	var i WvsTask
	err := row.Scan(
		&i.TaskID,
		&i.Wsid,
		&i.Op,
		&i.Status,
		&i.IdempotencyKey,
		&i.RequestHash,
		&i.CreatedAt,
		&i.StartedAt,
		&i.EndedAt,
		&i.Attempt,
		&i.MaxAttempts,
		&i.NextRunAt,
		&i.TimeoutSeconds,
		&i.CancelRequested,
		&i.Params,
		&i.Result,
		&i.Error,
	)
	return i, err
}

const dequeueTask = `-- name: DequeueTask :one
WITH picked AS (
  SELECT task_id
  FROM wvs.tasks
  WHERE status IN ('PENDING', 'FAILED')
    AND next_run_at <= now()
    AND attempt < max_attempts
  ORDER BY created_at
  FOR UPDATE SKIP LOCKED
  LIMIT 1
)
UPDATE wvs.tasks t
SET status = 'RUNNING', started_at = now(), attempt = attempt + 1
FROM picked
WHERE t.task_id = picked.task_id
RETURNING t.task_id, t.wsid, t.op, t.status, t.idempotency_key, t.request_hash, t.created_at, t.started_at, t.ended_at, t.attempt, t.max_attempts, t.next_run_at, t.timeout_seconds, t.cancel_requested, t.params, t.result, t.error
`

func (q *Queries) DequeueTask(ctx context.Context) (WvsTask, error) {
	row := q.db.QueryRow(ctx, dequeueTask)
	var i WvsTask
	err := row.Scan(
		&i.TaskID,
		&i.Wsid,
		&i.Op,
		&i.Status,
		&i.IdempotencyKey,
		&i.RequestHash,
		&i.CreatedAt,
		&i.StartedAt,
		&i.EndedAt,
		&i.Attempt,
		&i.MaxAttempts,
		&i.NextRunAt,
		&i.TimeoutSeconds,
		&i.CancelRequested,
		&i.Params,
		&i.Result,
		&i.Error,
	)
	return i, err
}

const failTask = `-- name: FailTask :exec
UPDATE wvs.tasks
SET status = 'FAILED', ended_at = now(), error = $2,
    next_run_at = now() + make_interval(secs => least(5 * power(2, attempt - 1), 300))
WHERE task_id = $1
`

type FailTaskParams struct {
	TaskID string `json:"task_id"`
	Error  []byte `json:"error"`
}

func (q *Queries) FailTask(ctx context.Context, arg FailTaskParams) error {
	_, err := q.db.Exec(ctx, failTask, arg.TaskID, arg.Error)
	return err
}

const getQueueDepth = `-- name: GetQueueDepth :one
SELECT count(*) FROM wvs.tasks
WHERE status IN ('PENDING', 'FAILED') AND next_run_at <= now() AND attempt < max_attempts
`

func (q *Queries) GetQueueDepth(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getQueueDepth)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTask = `-- name: GetTask :one
SELECT task_id, wsid, op, status, idempotency_key, request_hash, created_at, started_at, ended_at, attempt, max_attempts, next_run_at, timeout_seconds, cancel_requested, params, result, error FROM wvs.tasks WHERE task_id = $1
`

func (q *Queries) GetTask(ctx context.Context, taskID string) (WvsTask, error) {
	row := q.db.QueryRow(ctx, getTask, taskID)
	var i WvsTask
	err := row.Scan(
		&i.TaskID,
		&i.Wsid,
		&i.Op,
		&i.Status,
		&i.IdempotencyKey,
		&i.RequestHash,
		&i.CreatedAt,
		&i.StartedAt,
		&i.EndedAt,
		&i.Attempt,
		&i.MaxAttempts,
		&i.NextRunAt,
		&i.TimeoutSeconds,
		&i.CancelRequested,
		&i.Params,
		&i.Result,
		&i.Error,
	)
	return i, err
}

const getTaskByIdempotencyKey = `-- name: GetTaskByIdempotencyKey :one
SELECT task_id, wsid, op, status, idempotency_key, request_hash, created_at, started_at, ended_at, attempt, max_attempts, next_run_at, timeout_seconds, cancel_requested, params, result, error FROM wvs.tasks WHERE wsid = $1 AND op = $2 AND idempotency_key = $3
`

type GetTaskByIdempotencyKeyParams struct {
	Wsid           string `json:"wsid"`
	Op             string `json:"op"`
	IdempotencyKey string `json:"idempotency_key"`
}

func (q *Queries) GetTaskByIdempotencyKey(ctx context.Context, arg GetTaskByIdempotencyKeyParams) (WvsTask, error) {
	row := q.db.QueryRow(ctx, getTaskByIdempotencyKey, arg.Wsid, arg.Op, arg.IdempotencyKey)
	var i WvsTask
	err := row.Scan(
		&i.TaskID,
		&i.Wsid,
		&i.Op,
		&i.Status,
		&i.IdempotencyKey,
		&i.RequestHash,
		&i.CreatedAt,
		&i.StartedAt,
		&i.EndedAt,
		&i.Attempt,
		&i.MaxAttempts,
		&i.NextRunAt,
		&i.TimeoutSeconds,
		&i.CancelRequested,
		&i.Params,
		&i.Result,
		&i.Error,
	)
	return i, err
}

const listTasks = `-- name: ListTasks :many
SELECT task_id, wsid, op, status, idempotency_key, request_hash, created_at, started_at, ended_at, attempt, max_attempts, next_run_at, timeout_seconds, cancel_requested, params, result, error FROM wvs.tasks
WHERE ($2::text IS NULL OR wsid = $2::text)
  AND ($3::text IS NULL OR status = $3::text)
  AND ($4::text IS NULL OR op = $4::text)
  AND ($5::timestamptz IS NULL OR created_at < $5::timestamptz)
ORDER BY created_at DESC
LIMIT $1
`

type ListTasksParams struct {
	Limit  int32              `json:"limit"`
	Wsid   pgtype.Text        `json:"wsid"`
	Status pgtype.Text        `json:"status"`
	Op     pgtype.Text        `json:"op"`
	Cursor pgtype.Timestamptz `json:"cursor"`
}

func (q *Queries) ListTasks(ctx context.Context, arg ListTasksParams) ([]WvsTask, error) {
	rows, err := q.db.Query(ctx, listTasks,
		arg.Limit,
		arg.Wsid,
		arg.Status,
		arg.Op,
		arg.Cursor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WvsTask{}
	for rows.Next() {
		var i WvsTask
		if err := rows.Scan(
			&i.TaskID,
			&i.Wsid,
			&i.Op,
			&i.Status,
			&i.IdempotencyKey,
			&i.RequestHash,
			&i.CreatedAt,
			&i.StartedAt,
			&i.EndedAt,
			&i.Attempt,
			&i.MaxAttempts,
			&i.NextRunAt,
			&i.TimeoutSeconds,
			&i.CancelRequested,
			&i.Params,
			&i.Result,
			&i.Error,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markTaskDead = `-- name: MarkTaskDead :exec
UPDATE wvs.tasks SET status = 'DEAD', ended_at = now(), error = $2 WHERE task_id = $1
`

type MarkTaskDeadParams struct {
	TaskID string `json:"task_id"`
	Error  []byte `json:"error"`
}

func (q *Queries) MarkTaskDead(ctx context.Context, arg MarkTaskDeadParams) error {
	_, err := q.db.Exec(ctx, markTaskDead, arg.TaskID, arg.Error)
	return err
}

const requestCancelRunningTask = `-- name: RequestCancelRunningTask :one
UPDATE wvs.tasks SET cancel_requested = true
WHERE task_id = $1 AND status = 'RUNNING'
RETURNING task_id, wsid, op, status, idempotency_key, request_hash, created_at, started_at, ended_at, attempt, max_attempts, next_run_at, timeout_seconds, cancel_requested, params, result, error
`

func (q *Queries) RequestCancelRunningTask(ctx context.Context, taskID string) (WvsTask, error) {
	row := q.db.QueryRow(ctx, requestCancelRunningTask, taskID)
	var i WvsTask
	err := row.Scan(
		&i.TaskID,
		&i.Wsid,
		&i.Op,
		&i.Status,
		&i.IdempotencyKey,
		&i.RequestHash,
		&i.CreatedAt,
		&i.StartedAt,
		&i.EndedAt,
		&i.Attempt,
		&i.MaxAttempts,
		&i.NextRunAt,
		&i.TimeoutSeconds,
		&i.CancelRequested,
		&i.Params,
		&i.Result,
		&i.Error,
	)
	return i, err
}
