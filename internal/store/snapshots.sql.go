// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: snapshots.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSnapshot = `-- name: CreateSnapshot :one
INSERT INTO wvs.snapshots (snapshot_id, wsid, fs_path, message, created_at)
VALUES ($1, $2, $3, $4, now())
RETURNING snapshot_id, wsid, fs_path, message, created_at, deleted_at
`

type CreateSnapshotParams struct {
	SnapshotID string      `json:"snapshot_id"`
	Wsid       string      `json:"wsid"`
	FsPath     string      `json:"fs_path"`
	Message    pgtype.Text `json:"message"`
}

func (q *Queries) CreateSnapshot(ctx context.Context, arg CreateSnapshotParams) (WvsSnapshot, error) {
	row := q.db.QueryRow(ctx, createSnapshot,
		arg.SnapshotID,
		arg.Wsid,
		arg.FsPath,
		arg.Message,
	)
	var i WvsSnapshot
	err := row.Scan(
		&i.SnapshotID,
		&i.Wsid,
		&i.FsPath,
		&i.Message,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSnapshot = `-- name: GetSnapshot :one
SELECT snapshot_id, wsid, fs_path, message, created_at, deleted_at FROM wvs.snapshots WHERE snapshot_id = $1
`

func (q *Queries) GetSnapshot(ctx context.Context, snapshotID string) (WvsSnapshot, error) {
	row := q.db.QueryRow(ctx, getSnapshot, snapshotID)
	var i WvsSnapshot
	err := row.Scan(
		&i.SnapshotID,
		&i.Wsid,
		&i.FsPath,
		&i.Message,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const isSnapshotReferencedByTasks = `-- name: IsSnapshotReferencedByTasks :one
SELECT EXISTS(
  SELECT 1 FROM wvs.tasks
  WHERE wsid = $1
    AND status IN ('PENDING', 'RUNNING', 'FAILED')
    AND attempt < max_attempts
    AND op != 'snapshot_drop'
    AND params->>'snapshot_id' = $2::text
) AS referenced
`

type IsSnapshotReferencedByTasksParams struct {
	Wsid       string      `json:"wsid"`
	SnapshotID pgtype.Text `json:"snapshot_id"`
}

func (q *Queries) IsSnapshotReferencedByTasks(ctx context.Context, arg IsSnapshotReferencedByTasksParams) (bool, error) {
	row := q.db.QueryRow(ctx, isSnapshotReferencedByTasks, arg.Wsid, arg.SnapshotID)
	var referenced bool
	err := row.Scan(&referenced)
	return referenced, err
}

const listSnapshots = `-- name: ListSnapshots :many
SELECT snapshot_id, wsid, fs_path, message, created_at, deleted_at FROM wvs.snapshots
WHERE wsid = $1 AND deleted_at IS NULL
  AND ($3::timestamptz IS NULL OR created_at < $3::timestamptz)
ORDER BY created_at DESC
LIMIT $2
`

type ListSnapshotsParams struct {
	Wsid   string             `json:"wsid"`
	Limit  int32              `json:"limit"`
	Cursor pgtype.Timestamptz `json:"cursor"`
}

func (q *Queries) ListSnapshots(ctx context.Context, arg ListSnapshotsParams) ([]WvsSnapshot, error) {
	rows, err := q.db.Query(ctx, listSnapshots, arg.Wsid, arg.Limit, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WvsSnapshot{}
	for rows.Next() {
		var i WvsSnapshot
		if err := rows.Scan(
			&i.SnapshotID,
			&i.Wsid,
			&i.FsPath,
			&i.Message,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSnapshotDeleted = `-- name: MarkSnapshotDeleted :exec
UPDATE wvs.snapshots SET deleted_at = now() WHERE snapshot_id = $1
`

func (q *Queries) MarkSnapshotDeleted(ctx context.Context, snapshotID string) error {
	_, err := q.db.Exec(ctx, markSnapshotDeleted, snapshotID)
	return err
}
